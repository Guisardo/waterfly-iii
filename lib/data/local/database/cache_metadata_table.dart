import 'package:drift/drift.dart';

/// Cache Metadata Table
///
/// Stores metadata for cached entities to support the cache-first architecture
/// with stale-while-revalidate pattern.
///
/// This table tracks cache freshness, TTL, ETags for HTTP validation, and
/// supports LRU eviction through last access tracking. It works in conjunction
/// with entity-specific tables (transactions, accounts, etc.) which store the
/// actual cached data.
///
/// Key Features:
/// - TTL-based cache expiration for stale-while-revalidate
/// - Staleness detection via cachedAt + ttlSeconds comparison
/// - LRU eviction using lastAccessedAt for memory management
/// - ETag support for efficient HTTP cache validation (304 Not Modified)
/// - Query result caching via queryHash for collection queries
///
/// Composite Primary Key: (entityType, entityId)
/// - Ensures one metadata entry per cached entity
/// - Enables efficient lookups by type and ID
///
/// Index Strategy:
/// - cache_by_type: Fast lookup of all entities of a specific type
/// - cache_by_invalidation: Efficient queries for invalidated/stale entries
/// - cache_by_staleness: Quick freshness checks using cachedAt + ttlSeconds
/// - cache_by_lru: Ordered access for LRU eviction
///
/// Example Usage:
/// ```dart
/// // Cache a transaction with 5-minute TTL
/// await database.into(database.cacheMetadataTable).insert(
///   CacheMetadataEntityCompanion.insert(
///     entityType: 'transaction',
///     entityId: '123',
///     cachedAt: DateTime.now(),
///     lastAccessedAt: DateTime.now(),
///     ttlSeconds: 300, // 5 minutes
///     isInvalidated: false,
///   ),
/// );
///
/// // Check if cached entry is fresh
/// final metadata = await (database.select(database.cacheMetadataTable)
///   ..where((tbl) =>
///       tbl.entityType.equals('transaction') &
///       tbl.entityId.equals('123')))
///   .getSingleOrNull();
///
/// final isFresh = metadata != null &&
///     !metadata.isInvalidated &&
///     DateTime.now().isBefore(
///       metadata.cachedAt.add(Duration(seconds: metadata.ttlSeconds))
///     );
/// ```
@DataClassName('CacheMetadataEntity')
class CacheMetadataTable extends Table {
  /// Entity type identifier (e.g., 'transaction', 'account', 'budget').
  ///
  /// For single entities: use singular form ('transaction', 'account')
  /// For collections: use suffixed form ('transaction_list', 'account_list')
  ///
  /// This allows distinguishing between individual entity cache and
  /// collection query cache, which may have different TTLs and invalidation
  /// rules.
  ///
  /// Part 1 of composite primary key.
  TextColumn get entityType => text()();

  /// Entity identifier (server ID or cache key for collections).
  ///
  /// For single entities: use server ID ('123', '456', 'abc-def-ghi')
  /// For collections: use generated cache key from query hash
  ///   (e.g., 'collection_all', 'collection_abc123def456')
  ///
  /// Collection cache keys are generated by hashing query parameters
  /// (filters, pagination, sorting) using SHA-256 to ensure identical
  /// queries hit the same cache entry regardless of parameter order.
  ///
  /// Part 2 of composite primary key.
  TextColumn get entityId => text()();

  /// Timestamp when the data was cached.
  ///
  /// Used in conjunction with ttlSeconds to determine cache staleness.
  /// Formula: isStale = DateTime.now().isAfter(cachedAt + Duration(seconds: ttlSeconds))
  ///
  /// This timestamp is updated whenever the cache entry is refreshed
  /// (either through explicit refresh or background revalidation).
  ///
  /// Critical for stale-while-revalidate pattern:
  /// - Fresh: cachedAt + ttl > now → return immediately
  /// - Stale: cachedAt + ttl < now → return cached + background refresh
  DateTimeColumn get cachedAt => dateTime()();

  /// Timestamp when the cache entry was last accessed.
  ///
  /// Updated on every cache hit (both fresh and stale reads).
  /// Used for LRU (Least Recently Used) eviction when cache size exceeds limits.
  ///
  /// LRU eviction strategy:
  /// 1. Sort all entries by lastAccessedAt (ascending)
  /// 2. Evict oldest entries first until cache size under limit
  /// 3. Preserves frequently accessed data, removes cold cache entries
  ///
  /// This enables automatic cache size management without manual intervention,
  /// balancing memory usage with performance benefits of caching.
  DateTimeColumn get lastAccessedAt => dateTime()();

  /// Time-to-live in seconds defining cache freshness window.
  ///
  /// Determines how long cached data is considered fresh before becoming stale.
  /// Different entity types have different TTL values based on volatility:
  /// - Highly volatile (transactions): 300s (5 min)
  /// - Moderately volatile (accounts, budgets): 900s (15 min)
  /// - Low volatility (categories, currencies): 3600s (1 hour)
  /// - Rarely changing (user profile): 43200s (12 hours)
  ///
  /// TTL values configured in CacheTtlConfig based on:
  /// - Data volatility (how often it changes)
  /// - User expectations (how fresh data needs to be)
  /// - API cost (expensive queries get longer TTL)
  ///
  /// The TTL is stored as seconds for efficient database queries:
  /// ```sql
  /// SELECT * FROM cache_metadata
  /// WHERE datetime(cached_at, '+' || ttl_seconds || ' seconds') > datetime('now')
  /// ```
  IntColumn get ttlSeconds => integer()();

  /// Whether this cache entry has been explicitly invalidated.
  ///
  /// Set to true when:
  /// - Related entity is created/updated/deleted (cascade invalidation)
  /// - User performs pull-to-refresh
  /// - Sync operation completes
  /// - Manual cache clear requested
  ///
  /// Invalidated entries are treated as cache misses:
  /// - isFresh() returns false
  /// - Next get() will fetch from API
  /// - Background refresh will update and clear flag
  ///
  /// Default value: false (new cache entries start valid)
  ///
  /// This flag allows immediate cache invalidation without deleting the entry,
  /// preserving the cached data for potential stale-while-revalidate serving
  /// if API fetch fails.
  BoolColumn get isInvalidated =>
      boolean().withDefault(const Constant(false))();

  /// Optional ETag from HTTP response headers for cache validation.
  ///
  /// ETags enable efficient HTTP conditional requests:
  /// 1. Cache stores ETag from initial response
  /// 2. Subsequent request includes If-None-Match: `etag`
  /// 3. Server returns 304 Not Modified if unchanged (no body transfer)
  /// 4. Client reuses cached data, updates lastAccessedAt
  ///
  /// Bandwidth savings:
  /// - Full response: ~5-50 KB depending on entity
  /// - 304 response: ~200 bytes (headers only)
  /// - Reduction: 95-99% for unchanged data
  ///
  /// Nullable because:
  /// - Not all API endpoints support ETags
  /// - Legacy Firefly III versions may not return ETags
  /// - Cache can function without ETags (just less efficient)
  ///
  /// Format: Typically a hash or version identifier
  /// Example: "33a64df551425fcc55e4d42a148795d9f25f89d4"
  TextColumn get etag => text().nullable()();

  /// Optional query parameters hash for collection queries.
  ///
  /// Collection queries (e.g., "get all transactions") can have filters,
  /// pagination, sorting parameters. This hash ensures identical queries
  /// hit the same cache entry regardless of parameter order.
  ///
  /// Hash Generation Algorithm:
  /// 1. Normalize parameters: sort keys alphabetically
  /// 2. Serialize to JSON: {"account":"123","limit":50,"start":"2024-01-01"}
  /// 3. Hash with SHA-256
  /// 4. Truncate to 16 characters for efficiency
  /// 5. Prefix with 'collection_': 'collection_abc123def456'
  ///
  /// Benefits:
  /// - Query param order doesn't affect cache hit
  ///   (?limit=50&account=123 === ?account=123&limit=50)
  /// - Deterministic cache keys for testing
  /// - Human-readable prefix for debugging
  ///
  /// Nullable because:
  /// - Single entity queries don't need it (use server ID)
  /// - Some collections have no parameters ('get all')
  ///
  /// Example:
  /// ```dart
  /// // Query: transactions?start=2024-01-01&end=2024-01-31&account=123
  /// final hash = sha256('{"account":"123","end":"2024-01-31","start":"2024-01-01"}');
  /// queryHash = 'collection_${hash.substring(0, 16)}';
  /// ```
  TextColumn get queryHash => text().nullable()();

  /// Cached data stored as JSON string.
  ///
  /// Used to persist computed data (charts, insights) that doesn't have
  /// dedicated entity tables. This allows the app to display cached data
  /// even after restart when offline.
  ///
  /// Stored as JSON to support various data types:
  /// - List of ChartDataSet for chart data
  /// - List of InsightTotalEntry for insight totals
  /// - List of InsightGroupEntry for insight groups
  /// - List of BudgetLimitRead for budget limits
  ///
  /// Nullable because:
  /// - Entity data stored in dedicated tables (transactions, accounts) doesn't need this
  /// - Only computed/aggregated data (charts, insights) uses this column
  /// - Reduces storage for entities that don't need it
  ///
  /// Example:
  /// ```dart
  /// // Store chart data
  /// final chartData = [ChartDataSet(...), ChartDataSet(...)];
  /// final jsonData = jsonEncode(chartData.map((e) => e.toJson()).toList());
  /// await database.into(cacheMetadataTable).insert(
  ///   CacheMetadataEntityCompanion.insert(
  ///     entityType: 'chart_account',
  ///     entityId: 'account_overview_2024-01-01_2024-01-31',
  ///     cachedData: jsonData,
  ///     // ... other fields
  ///   ),
  /// );
  /// ```
  TextColumn get cachedData => text().nullable()();

  /// Composite primary key: (entityType, entityId)
  ///
  /// Ensures one cache metadata entry per entity.
  /// Both columns required for uniqueness:
  /// - entityType alone: not unique (many transactions)
  /// - entityId alone: not unique (same ID across entity types)
  /// - Combined: unique per cached entity
  ///
  /// This enables efficient upsert operations (insert or update):
  /// ```dart
  /// await database.into(cacheMetadataTable).insertOnConflictUpdate(
  ///   CacheMetadataEntityCompanion.insert(
  ///     entityType: 'account',
  ///     entityId: '123',
  ///     cachedAt: DateTime.now(),
  ///     // ... other fields
  ///   ),
  /// );
  /// ```
  @override
  Set<Column> get primaryKey => <Column<Object>>{entityType, entityId};

  /// Custom indexes for query performance optimization.
  ///
  /// Note: Indexes are created via SQL statements in database migration
  /// (see app_database.dart onUpgrade version 5) rather than using
  /// Drift's customIndexes to avoid syntax issues.
  ///
  /// These indexes dramatically improve cache operation performance:
  /// - Type invalidation: O(log n) instead of O(n) table scan
  /// - Staleness checks: Index-covered query for freshness
  /// - LRU eviction: Ordered access without full table sort
  ///
  /// Index 1: cache_by_type
  /// - Columns: [entityType]
  /// - Use case: Invalidate all entries of a type
  /// - Query: DELETE FROM cache_metadata WHERE entity_type = 'transaction'
  /// - Without index: Full table scan
  /// - With index: O(log n) + O(k) where k = matching rows
  ///
  /// Index 2: cache_by_invalidation
  /// - Columns: [isInvalidated, cachedAt]
  /// - Use case: Find invalidated or stale entries for cleanup
  /// - Query: SELECT * FROM cache_metadata WHERE is_invalidated = 1
  /// - Composite index enables efficient filtering and sorting
  ///
  /// Index 3: cache_by_staleness
  /// - Columns: [cachedAt, ttlSeconds]
  /// - Use case: Fast freshness checks
  /// - Query: Check if cached_at + ttl_seconds > NOW()
  /// - Both columns needed for staleness calculation
  ///
  /// Index 4: cache_by_lru
  /// - Columns: [lastAccessedAt]
  /// - Use case: LRU eviction ordering
  /// - Query: SELECT * FROM cache_metadata ORDER BY last_accessed_at ASC
  /// - Enables efficient "least recently used" queries for eviction
  ///
  /// Index Maintenance Cost:
  /// - Storage: ~10-20% overhead per index
  /// - Insert/Update: Slightly slower (updates all indexes)
  /// - Query: 10-1000x faster for indexed queries
  /// - Trade-off: Worth it for cache-heavy workload
}
